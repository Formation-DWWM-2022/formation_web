# SOLID

- PHP 8 - Programmation Orient√©e Objet - #19 Les principes SOLID : https://youtu.be/xMmxOMM1J5I
- SOLID: Les principes √† l'origine du succ√®s de Symfony et de vos applications - Vladyslav Riabchenko : https://youtu.be/1a50ZzQUUps
- Faire un d√©veloppement SOLID - Architecture et bonnes pratiques : https://youtu.be/JlHYFsqYWFU
- OpenClassrooms - √âcrivez du PHP maintenable avec les principes SOLID et les design patterns : https://openclassrooms.com/fr/courses/7415611-ecrivez-du-php-maintenable-avec-les-principes-solid-et-les-design-patterns

Vous avez d√©velopp√© vos premi√®res applications en PHP et vous souhaitez passer √† la vitesse sup√©rieure ?

Dans ce cours, vous allez apprendre √† √©crire un code propre et compr√©hensible par les autres d√©veloppeurs et d√©veloppeuses.

Ensemble, nous d√©couvrirons les bonnes pratiques SOLID, et comment les utiliser dans vos d√©veloppements actuels et √† venir.

SOLID, en informatique, c‚Äôest quelque chose dont on entend souvent parler.

SOLID est un acronyme des cinq premiers principes de la conception orient√©e objet (OOD) de Robert C. Martin (√©galement connu sous le nom de d‚Äôoncle Bob).

Que ce soit entre d√©veloppeurs ou via des formations, on retrouve souvent cet acronyme dans les slides de pr√©sentation.

Et cela depuis des ann√©es‚Ä¶

Si tu en parles avec un autre dev, il te dira s√ªrement qu‚Äôil faut faire du code SOLID !

Que SOLID, ce sont les bonnes pratiques, que c‚Äôest g√©nial, que c‚Äôest obligatoire pour progresser.

Mais est-ce vraiment le cas ?

Je te montrerai que ce n‚Äôest pas que de la th√©orie et que tu peux utiliser SOLID tous les jours dans ton code pour le rendre plus qualitatif !

Conna√Ætre les principes SOLID c‚Äôest bien, mais les appliquer dans son code, c‚Äôest mieux.

# Qu‚Äôest-ce que SOLID ?

Tu dois sans doute d√©j√† conna√Ætre quelques initiales, les voici au complet.

SOLID, c‚Äôest un acronyme pour ces 5 principes de programmation.

- S : Single Responsibility Principle
- O : Open/Closed Principle
- L : Liskov‚Äôs Substitution Principle
- I : Interface Segregation Principle
- D : Dependency Inversion Principle

Le but n‚Äôest pas de les conna√Ætre par c≈ìur, mais de suffisamment les comprendre pour pouvoir les utiliser.

En informatique, ces principes sont consid√©r√©s comme des bonnes pratiques pour les d√©veloppeurs.

Nous sommes cens√©s les appliquer afin de produire du code de qualit√©.

C‚Äôest √ßa SOLID.

Mais bon dans la pratique, je vois tr√®s peu de personnes appliquer ces principes en entreprise ! üôÅ

# Pourquoi faire du code SOLID ?

SOLID est un ensemble de (seulement) 5 bonnes pratiques dont le but est de rendre le code :

- Moins bogu√©
- Plus facile √† lire
- Plus logique
- Maintenable
- Testable
- Extensible (tu changes une partie du programme et il continue de fonctionner)

Comprendre SOLID et l‚Äôutiliser au quotidien te permettront surtout d‚Äôam√©liorer la qualit√© de ton code et de comprendre des codes plus √©volu√©s (comme celui de ton framework par exemple).

En une ligne : cela te fera devenir un meilleur d√©veloppeur.

Tu as donc tout int√©r√™t √† comprendre ces principes, et mieux encore, √† les appliquer dans ton quotidien de dev.

Faire du code SOLID diminuera grandement la dette technique de tes projets.

Une raison de plus de te former √† son utilisation !

# Comment utiliser SOLID dans son code (avec exemples concrets) ?

Dans cette partie, j‚Äôaimerais te montrer comment tu peux inclure du code SOLID dans ton projet sans que cela devienne compliqu√©.

Le plus gros frein √† l'utilisation des principes de SOLID, c'est que tout le monde pense que c'est compliqu√© et que c'est r√©serv√© aux g√©nies du dev.

Mais SOLID n‚Äôest pas si compliqu√© que √ßa √† comprendre.

Le seul pr√©requis pour bien le ma√Ætriser, c‚Äôest d‚Äôavoir un peu d‚Äôexp√©rience en programmation.

Avant de commencer, ne sois pas frustr√© de ne pas tout comprendre du premier coup.

Personnellement, j‚Äôai mis des mois √† assimiler ces notions.

Mais quand tu arriveras √† comprendre et √† utiliser les principes SOLID dans ton code, ta carri√®re de d√©veloppeur fera un bond en avant.

# S : Single Responsibility Principle (SRP)

C‚Äôest sans doute le principe le plus simple √† comprendre dans SOLID.

    Une classe ne doit avoir qu'une seule et unique responsabilit√©.

    Une classe doit avoir une seule et unique raison de changer, ce qui signifie qu‚Äôune classe ne doit appartenir qu‚Äô√† une seule t√¢che.

Une erreur que l‚Äôon retrouve beaucoup dans les projets, c‚Äôest d‚Äôavoir une classe type `UserService.php` avec tout et n‚Äôimporte quoi dedans.

De plus, le nom `UserService.php` n‚Äôest pas du tout explicite, on ne sait pas ce que le fichier contient.

Double probl√®me !

## ‚ùå Code qui ne respecte pas le principe de responsabilit√© unique (SRP)

```php
/**
*** Single Responsibility Principle in PHP (not working)
**/

class UserService 
{
	public function updateFromAPI( User $user): User
	{
		// ...	
	}

	public function removeSession( User $user ): void
	{
		// ...	
	}

	public function isUserAllowedToAccessAdmin( User $user ): bool
	{
		// ...
	}

	public function serialize( User $user ): string
	{
		// ...
	}
}
```

Ici, `UserService.php` a plusieurs r√¥les (ou responsabilit√©s).

- G√©rer la mise √† jour d‚Äôun utilisateur
- G√©rer la session de l‚Äôutilisateur
- V√©rifier ses droits
- Convertir l‚Äôobjet d‚Äôun format vers un autre

Cela fait d√©j√† pas mal, et encore.

G√©n√©ralement quand cela commence comme √ßa sur les projets, on se retrouve avec des services un peu fourre-tout de plusieurs centaines de lignes.

Plusieurs m√©thodes qui font la m√™me chose, le code est dupliqu√© de toute part, les classes deviennent de plus en plus lourdes‚Ä¶

√Ä maintenir c‚Äôest tr√®s compliqu√©.

## ‚úÖ Code PHP qui respecte le principe de responsabilit√© unique (SRP)

Reprenons l‚Äôexemple ci-dessus.

Plut√¥t que d‚Äôavoir une arborescence de telle sorte.

```
Services/
‚îî‚îÄ‚îÄ UserService.php
‚îú‚îÄ‚îÄ ...
```

Et ainsi avoir un service √©norme par type de donn√©es (comme UserService, ImageService, StatsService‚Ä¶) qui contient beaucoup (trop) de codes.

On applique le principe SRP qui va naturellement tendre vers une arborescence plus facile √† lire.

```
Services/
‚îú‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ User
    ‚îú‚îÄ‚îÄ UserAuthenticatorService.php
    ‚îú‚îÄ‚îÄ UserFormatterService.php
    ‚îú‚îÄ‚îÄ UserSessionService.php
    ‚îî‚îÄ‚îÄ UserUpdatorService.php
    ‚îú‚îÄ‚îÄ ...
```

Et voici le code s√©par√© par fichier.

```php
/**
 * Single Responsibility Principle in PHP
 * 
 * Each class should be stored in a folder called Services/User/*.
 */

// Located in Services/User/UserAuthenticatorService.php
class UserAuthenticatorService
{
	public function isAllowedToAccessAdmin( User $user ): bool
	{
		// ...
	}
}

// Located in Services/User/UserFormatterService.php
class UserFormatterService
{
	public function serialize( User $user ): string
	{
		// ...
	}
}

// Located in Services/User/UserSessionService.php
class UserSessionService
{
	public function invalidate( User $user ): void
	{
		// ...
	}
}

// Located in Services/User/UserUpdatorService.php
class UserUpdatorService
{
	public function updateFromAPI( User $user): User
	{
		// ...
	}
}
```

## ‚ùå Code qui ne respecte pas le principe de responsabilit√© unique (SRP)

Par exemple, imaginez une application qui prend un ensemble de formes (cercles et carr√©s) et calcule la somme de la superficie de toutes les formes de l‚Äôensemble.

Tout d‚Äôabord, vous devez cr√©er les classes de forme et configurer les param√®tres requis des constructeurs.

Pour les carr√©s, vous devrez conna√Ætre la longueur d‚Äôun c√¥t√© :

```php
class Square
{
    public $length;

    public function construct($length)
    {
        $this->length = $length;
    }
}
```

Pour les cercles, vous devrez conna√Ætre le rayon :

```php
class Circle
{
    public $radius;

    public function construct($radius)
    {
        $this->radius = $radius;
    }
}
```

Ensuite, cr√©ez la classe AreaCalculator et √©crivez la logique pour additionner les superficies de toutes les formes fournies. La superficie d‚Äôun carr√© se calcule avec la longueur au carr√©. La superficie d‚Äôun cercle se calcule en multipliant pi par le rayon au carr√©.

```php
class AreaCalculator
{
    protected $shapes;

    public function __construct($shapes = [])
    {
        $this->shapes = $shapes;
    }

    public function sum()
    {
        foreach ($this->shapes as $shape) {
            if (is_a($shape, 'Square')) {
                $area[] = pow($shape->length, 2);
            } elseif (is_a($shape, 'Circle')) {
                $area[] = pi() * pow($shape->radius, 2);
            }
        }

        return array_sum($area);
    }

    public function output()
    {
        return implode('', [
          '',
              'Sum of the areas of provided shapes: ',
              $this->sum(),
          '',
      ]);
    }
}
```

Pour utiliser la classe AreaCalculator, vous devrez instancier la classe, y passer un tableau de formes et afficher la sortie au bas de la page.

```php
$shapes = [
  new Circle(2),
  new Square(5),
  new Square(6),
];

$areas = new AreaCalculator($shapes);

echo $areas->output();
```

Le probl√®me avec la m√©thode de sortie est que l‚ÄôAreaCalculator g√®re la logique qui g√©n√®re les donn√©es.

Imaginez un sc√©nario o√π la sortie doit √™tre convertie dans un autre format, comme JSON.

L‚Äôingralit√© de la logique serait trait√©e par la classe AreaCalculator. Cela viendrait enfreindre le principe de responsabilit√© unique. La classe AreaCalculator doit uniquement s‚Äôoccuper de la somme des superficies des formes fournies. Elle ne doit pas chercher √† savoir si l‚Äôutilisateur souhaite un format JSON ou HTML.

## ‚úÖ Code PHP qui respecte le principe de responsabilit√© unique (SRP)

Pour y rem√©dier, vous pouvez cr√©er une classe SumCalculatorOutputter distincte. Ensuite, utilisez cette nouvelle classe pour g√©rer la logique dont vous avez besoin pour g√©n√©rer les donn√©es sur l‚Äôutilisateur :

```php
class SumCalculatorOutputter
{
    protected $calculator;

    public function __constructor(AreaCalculator $calculator)
    {
        $this->calculator = $calculator;
    }

    public function JSON()
    {
        $data = [
          'sum' => $this->calculator->sum(),
      ];

        return json_encode($data);
    }

    public function HTML()
    {
        return implode('', [
          '',
              'Sum of the areas of provided shapes: ',
              $this->calculator->sum(),
          '',
      ]);
    }
}
```

La classe SumCalculatorOutputter fonctionnerait comme suit :

```php
$shapes = [
  new Circle(2),
  new Square(5),
  new Square(6),
];

$areas = new AreaCalculator($shapes);
$output = new SumCalculatorOutputter($areas);

echo $output->JSON();
echo $output->HTML();
```

Maintenant, la logique dont vous avez besoin pour g√©n√©rer les donn√©es pour l‚Äôutilisateur est trait√©e par la classe SumCalculatorOutputter.

## ‚≠êÔ∏è Pourquoi utiliser le principe de responsabilit√© unique (SRP) ?

- Le code est beaucoup plus clair (une classe de 1000 lignes, ce n‚Äôest pas clair).
- Chaque fichier a d√©sormais un r√¥le qui lui est propre.
- Tout le monde peut comprendre √† quoi servent les classes dans le dossier Services/User gr√¢ce √† au nommage.
- Le projet sera beaucoup plus maintenable, plus facile et agr√©able √† faire √©voluer.

# O : Open/Closed Principle

On commence √† rentrer dans le vif du sujet.

    Les entit√©s doivent √™tre ouvertes √† l'extension et ferm√©es √† la modification.

Cela signifie que l‚Äôon doit toujours favoriser l‚Äôextension du code √† sa modification : on ne modifie pas le fonctionnement suivant l‚Äôentit√© √† utiliser, on d√©finit une fonction commune.

Souviens-toi de ceci :

Si tu commences √† utiliser des `instanceof` avec des `if` ou des `switch case` en fonction d‚Äôun type, c‚Äôest sans doute que tu es tomb√© dans le pi√®ge.

## ‚ùå Code qui ne respecte pas le principe ouvert/ferm√© (OC)

La plupart des exemples du principe d‚Äôouverture / fermeture que tu trouves sur internet te parlent d‚Äôobjet, d‚Äôentit√©.

Mais cela s‚Äôapplique √©galement aux services, modules, fonctions, classes‚Ä¶

Ici je choisis d‚Äôafficher un message de bienvenue √† mon utilisateur, et peu importe son type, mon action ne doit pas √™tre modifi√©e pour chaque √©l√©ment, m√™me si son affichage est diff√©rent.

Malheureusement dans ce code, mon action `displayWelcomeMessage()` se devra de changer au fur et √† mesure que j‚Äôajouterai des types d‚Äôutilisateurs‚Ä¶

```php
/**
 * Open/Closed principle in PHP (not working)
 */

class User
{
    public $name;
    public $firstname;

    public function __construct(string $firstname, string $name)
    {
        $this->firstname = $firstname;
        $this->name = $name;
    }
}

class Customer
{
    public $fullname;

    public function __construct(string $fullname)
    {
        $this->fullname = $fullname;
    }
}

class AccountDisplayerService
{
    public function displayWelcomeMessage(User | Customer $entity): void
    {
        if ($entity instanceof User) {
            printf("Hello, %s %s", strtoupper($entity->name), $entity->firstname);
        } elseif ($entity instanceof Customer) {
            printf("Welcome again, dear %s\n", $entity->fullname);
        }
    }
}

$user = new User('Lucien', 'Bramard');
$customer = new Customer('Mr Elliot Alderson');

$accountDisplayer = new AccountDisplayerService();

$accountDisplayer->displayWelcomeMessage($user);
$accountDisplayer->displayWelcomeMessage($customer);
```

Si je veux rajouter un nouveau type d‚Äôutilisateur, disons un affili√©, je vais devoir (encore) modifier le service qui fait l‚Äôaction.

C‚Äôest contraire au principe ouvert / ferm√©.

## ‚úÖ Code qui respecte le principe ouvert/ferm√© (OC)

Voici comment nous avons rendu notre code conforme.

- Ouvert pour l‚Äôextension : c‚Äôest le cas ci-dessous, on peut √©tendre le comportement d‚Äôune m√©thode (ici theName()), chaque classe qui l‚Äôimpl√©mente fait ce qu‚Äôelle veut dans sa m√©thode.
- Ferm√© √† la modification : on ne change pas le code source de l‚Äôaction en fonction du param√®tre re√ßu (que j‚Äôai un client, un utilisateur, un affili√©, un administrateur ou que sais-je, le code de l‚Äôaction ne sera pas modifi√©).

```php
/**
 *  Open/Closed Principle in PHP
 */

interface NameableInterface {
    public function theName(): void;
}

class User implements NameableInterface
{
    public $name;
    public $firstname;

    public function __construct(string $firstname, string $name)
    {
        $this->firstname = $firstname;
        $this->name = $name;
    }

    public function theName(): void
    {
        printf("Hello, %s %s", strtoupper($this->name), $this->firstname);
    }
}

class Customer implements NameableInterface
{
    public $fullname;

    public function __construct(string $fullname)
    {
        $this->fullname = $fullname;
    }

    public function theName(): void
    {
        printf("Welcome again, dear %s\n", $this->fullname);
    }
}

class AccountDisplayerService
{
    public function displayWelcomeMessage(NameableInterface $entity): void
    {
        $entity->theName();
    }
}

$user = new User('Lucien', 'Bramard');
$customer = new Customer('Mr Elliot Alderson');

$accountDisplayer = new AccountDisplayerService();

$accountDisplayer->displayWelcomeMessage($user);
$accountDisplayer->displayWelcomeMessage($customer);
```

Le choix d‚Äôune interface m‚Äôa permis de d√©terminer une action dans le service.

D√©sormais je n‚Äôai plus √† modifier le comportement de mon service √† chaque ajout d‚Äôentit√©.

L‚Äôinterface m‚Äôa permis de cr√©er un contrat entre le service et l‚Äôobjet qui est affich√©.

En une ligne :

¬´ Tu veux que je t‚Äôaffiche ? Pas de probl√®me, impl√©mente juste l‚Äôinterface NameableInterface ! ¬ª

## ‚ùå Code qui ne respecte pas le principe ouvert/ferm√© (OC)

Reprenons la classe AreaCalculator et concentrons sur la m√©thode sum :

```php
class AreaCalculator
{
    protected $shapes;

    public function __construct($shapes = [])
    {
        $this->shapes = $shapes;
    }

    public function sum()
    {
        foreach ($this->shapes as $shape) {
            if (is_a($shape, 'Square')) {
                $area[] = pow($shape->length, 2);
            } elseif (is_a($shape, 'Circle')) {
                $area[] = pi() * pow($shape->radius, 2);
            }
        }

        return array_sum($area);
    }
}
```

Imaginez qu‚Äôun utilisateur souhaite conna√Ætre la somme (sum) de formes suppl√©mentaires comme des triangles, des pentagones, des hexagones, etc. Il vous faudrait constamment modifier ce fichier et ajouter des blocs if/else. Cela viendrait enfreindre le principe ouvert/ferm√©

## ‚úÖ Code qui respecte le principe ouvert/ferm√© (OC)

Il existe un moyen de rendre cette m√©thode sum plus simple qui consiste √† supprimer la logique qui permet de calculer la superficie de chaque forme de la m√©thode de la classe AreaCalculator et la joindre √† la classe de chaque forme.

Voici la m√©thode area d√©finie dans Square :

```php
class Square
{
    public $length;

    public function __construct($length)
    {
        $this->length = $length;
    }

    public function area()
    {
        return pow($this->length, 2);
    }
}
```

Et voici la m√©thode area d√©finie dans Circle :

```php
class Circle
{
    public $radius;

    public function construct($radius)
    {
        $this->radius = $radius;
    }

    public function area()
    {
        return pi() * pow($shape->radius, 2);
    }
}
```

Vous pourrez alors r√©√©crire la m√©thode sum pour AreaCalculator de la mani√®re suivante :

```php
class AreaCalculator
{
    // ...

    public function sum()
    {
        foreach ($this->shapes as $shape) {
            $area[] = $shape->area();
        }

        return array_sum($area);
    }
}
```

Maintenant, vous pouvez cr√©er une autre classe de forme et la passer dans le calcul de la somme sans briser le code.

Cependant, un autre probl√®me se pose. Comment savoir si l‚Äôobjet pass√© dans l‚ÄôAreaCalculator est r√©ellement une forme ou si la forme a une m√©thode nomm√©e area ?

Cr√©ez une ShapeInterface qui prend en charge area :

```php
interface ShapeInterface
{
    public function area();
}
```

Modifiez vos classes de forme pour impl√©menter la ShapeInterface.

Voici la mise √† jour faite √† Square :

```php
class Square implements ShapeInterface
{
    // ...
}
```

Et voici la mise √† jour faite √† Circle :

```php
class Circle implements ShapeInterface
{
    // ...
}
```

Dans la m√©thode sum pour AreaCalculator, vous pouvez v√©rifier si les formes fournies sont effectivement des instances de la ShapeInterface. Dans le cas contraire, lancez une exception :

```php
class AreaCalculator
{
    // ...

    public function sum()
    {
        foreach ($this->shapes as $shape) {
            if (is_a($shape, 'ShapeInterface')) {
                $area[] = $shape->area();
                continue;
            }

            throw new AreaCalculatorInvalidShapeException();
        }

        return array_sum($area);
    }
}
```

## ‚≠êÔ∏è Pourquoi utiliser le principe ouvert/ferm√© (OC) ?

- Un code beaucoup plus lisible et plus clair.
- On aura beaucoup moins de bugs ou de comportements bizarres.
- En termes de maintenabilit√©, c‚Äôest g√©nial, car l‚Äôinterface et son contrat te permettent de savoir o√π tu vas.

# L : Liskov‚Äôs Substitution Principle (LSP)

Le principe de substitution de Barbara Liskov.

    Les objets dans un programme doivent √™tre rempla√ßables par des instances de leur sous-type sans pour autant alt√©rer le bon fonctionnement du programme.

L‚Äôid√©e du principe est que les enfants ne peuvent pas faire plus ou moins que leur parent.

Voici les 4 conditions que tu dois remplir pour √™tre conforme au Liskov‚Äôs Substitution Principle.

- La signature des fonctions (param√®tres et retour) doit √™tre identique entre l‚Äôenfant et le parent.
- Les param√®tres de la fonction de l‚Äôenfant ne peuvent pas √™tre plus nombreux que ceux du parent.
- Le retour de la fonction doit retourner le m√™me type que le parent.
- Les exceptions retourn√©es doivent √™tre les m√™mes.

En pratique, lorsque l‚Äôon utilise une classe abstraite, il est rarement possible de ne pas respecter les principes 1, 2 et 3 car ton langage t‚Äôy ¬´ obligera ¬ª.

## ‚ùå Code qui ne respecte pas le principe de substitution de Liskov (LSP)

Un exemple parlant est de cr√©er un syst√®me pour r√©cup√©rer des articles en base de donn√©es suivant le CMS (comme WordPress, Joomla, MediaWiki‚Ä¶).

```php
/**
 * Liskov‚Äôs Substitution Principle (LSP) in PHP (not working) 
 */

abstract class CMS 
{
    abstract public function findArticles(int $limit);
}   
    
class WordPress extends CMS
{
    /**
     * @param int $limit
     * @return array
     * @throws \Exception|\Doctrine\DBAL\Driver\Exception
     */
    public function findArticles(int $limit)
    {
        // ‚ùå Throws a different exception, Joomla's class cannot do it.
        $connection = $this->getEntityManager()->getConnection();

        $statement = $connection->prepare
        (
            'SELECT
              post_title AS title
              post_content AS content
              post_date AS createdAt
            FROM `post`
            WHERE `post_type` = "post"
                AND `post_status` = "publish"
            ORDER BY `post_date` DESC
            LIMIT :limit'
        );
        $statement->bindValue(':limit', $limit, PDO::PARAM_INT);

        return $statement->fetchAll();
    }
}

class Joomla extends CMS
{
    public function findArticles(int $limit)
    {
      try {
          $pdo = new PDO('...');

          $statement = $pdo->prepare
          (
              'SELECT
                `title` AS title,
                `fulltext` AS content,
                `publish_up` AS createdAt
              FROM content
              WHERE `state` = 1
              ORDER BY `publish_up` DESC
              DESC LIMIT 10'
          );

          return $statement->fetchAll();
        } catch (\Exception $e) {
          // ‚ùå Return type is string, we are supposed to return array.
          return $e->getMessage();
        }
    }
}
```

Plusieurs choses ne vont pas dans ce code :

- Pas les m√™mes retours de fonction.
- Des exceptions diff√©rentes suivant les enfants.

Heureusement les param√®tres en entr√©e ne changent pas‚Ä¶

## ‚úÖ Code qui respecte le principe de substitution de Liskov (LSP)

Pour rappel, un enfant (un objet) ne peut pas faire plus ou moins que son parent (une interface ou une classe parente, abstraite ou non).

```php
/**
 * Liskov‚Äôs Substitution Principle (LSP) in PHP
 */

abstract class CMS
{
    abstract public function findArticles(int $limit = 10): array;

    /**
     * @throws PDOException
     */
    public function getConnection(): PDO
    {
        $pdo = new PDO('');
        
        $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
        $pdo->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
        
        return $pdo;
    }
}

class WordPress extends CMS
{
    public function findArticles(int $limit = 10): array
    {
        $pdo = $this->getConnection();

        $statement = $pdo->prepare
        (
            'SELECT
              post_title AS title
              post_content AS content
              post_date AS createdAt
            FROM `post`
            WHERE `post_type` = "post"
                AND `post_status` = "publish"
            ORDER BY `post_date` DESC
            LIMIT :limit'
        );
        $statement->bindValue(':limit', $limit, PDO::PARAM_INT);

        return $statement->fetchAll();
    }
}

class Joomla extends CMS
{
    public function findArticles(int $limit = 10): array
    {
        $pdo = $this->getConnection();

        $statement = $pdo->prepare
        (
            'SELECT
              `title` AS title,
              `fulltext` AS content,
              `publish_up` AS createdAt
            FROM content
            WHERE `state` = 1
            ORDER BY `publish_up` DESC
            DESC LIMIT :limit'
        );
        $statement->bindValue(':limit', $limit, PDO::PARAM_INT);

        return $statement->fetchAll();
    }
}
```

J‚Äôai d√©clar√© une classe abstraite parente √† √©tendre pour √™tre certain que chacun des enfants me retourne bien une liste d‚Äôarticles avec une limite en entr√©e.

Partout dans mon code, je peux donc interchanger WordPress et Joomla, sans que √ßa ne casse rien.

Ces deux classes respectent la d√©finition du parent, elles ne font ni plus, ni moins.

On sait √† quoi s‚Äôattendre en les utilisant.

Voici un autre exemple du principe de substitution de Liskov avec PHP.

```php
class Vehicle
{
}

class Car extends Vehicle
{
}

class Boat extends Vehicle {

}

abstract class VehicleManager
{
    abstract function sell(Vehicle $vehicle): void;
}

class CarManager extends VehicleManager
{
    function sell(Car $car): void // ‚ùå Declaration of CarManager::sell(Car $car): void must be compatible with VehicleManager::sell(Vehicle $vehicle):
    {
        /**
         * This is a limitation of PHP language, technically speaking, this is NOT an error.
         *
         * If you wish to do so, use interfaces!
         */
    }
}

$carManager = new CarManager();
$carManager->sell(new Car());

class VehicleOrder
{
    /**
     * Children can be substitute with there parent.
     */
    function order(Vehicule $vehicle)
    {
    }
}

$vehicleOrder = new VehicleOrder();
$vehicleOrder->order(new Car()); // substitution works, it is all ok üëå
$vehicleOrder->order(new Boat()); // substitution works, it is all ok üëå
```

Ici, on ne peut pas typer le service enfant (CarManager) avec l‚Äôenfant (Car) alors que pourtant, nous pourrions‚Ä¶

PHP nous oblige √† respecter notre contrat avec la classe abstraite et d‚Äôutiliser un Vehicle !

La m√©thode sell(Vehicle $vehicle) ne peut donc pas √™tre surcharg√©e dans l‚Äôenfant (CarManager) avec un type diff√©rent que Vehicle.

Quand bien m√™me nous respecterions le principe de substitution de Liskov.

C‚Äôest une limitation de PHP.

En revanche, il est tout √† fait possible de substituer les objets entre eux dans un appel de fonction (comme l‚Äôappel order()).

## ‚ùå Code qui ne respecte pas le principe de substitution de Liskov (LSP)

En reprenant l‚Äôexemple de la classe AreaCalculator, imaginez une nouvelle classe VolumeCalculator qui √©tend la classe AreaCalculator :

```php
class VolumeCalculator extends AreaCalculator
{
    public function construct($shapes = [])
    {
        parent::construct($shapes);
    }

    public function sum()
    {
        // logic to calculate the volumes and then return an array of output
        return [$summedData];
    }
}
```

Rappelez-vous que la classe SumCalculatorOutputter ressemble √† ce qui suit :

```php
class SumCalculatorOutputter {
    protected $calculator;

    public function __constructor(AreaCalculator $calculator) {
        $this->calculator = $calculator;
    }

    public function JSON() {
        $data = array(
            'sum' => $this->calculator->sum();
        );

        return json_encode($data);
    }

    public function HTML() {
        return implode('', array(
            '',
                'Sum of the areas of provided shapes: ',
                $this->calculator->sum(),
            ''
        ));
    }
}
```

Si vous avez essay√© d‚Äôex√©cuter un exemple comme celui-ci :

```php
$areas = new AreaCalculator($shapes);
$volumes = new VolumeCalculator($solidShapes);

$output = new SumCalculatorOutputter($areas);
$output2 = new SumCalculatorOutputter($volumes);
```

Une fois que vous appelez la m√©thode HTML sur l‚Äôobjet $output2, vous obtiendrez une erreur E_NOTICE vous informant de la conversion d‚Äôun tableau en cha√Ænes de caract√®res.

## ‚úÖ Code qui respecte le principe de substitution de Liskov (LSP)

Pour corriger ce probl√®me, au lieu de renvoyer un tableau √† partir de la m√©thode de somme de la classe VolumeCalculator, renvoyez $summedData :

```php
class VolumeCalculator extends AreaCalculator
{
    public function construct($shapes = [])
    {
        parent::construct($shapes);
    }

    public function sum()
    {
        // logic to calculate the volumes and then return a value of output
        return $summedData;
    }
}
```

Le $summedData peut √™tre un d√©cimal, un double ou un entier.

## ‚≠êÔ∏è Pourquoi utiliser le principe de substitution de Liskov (LSP) ?

- √áa √©vite les bogues o√π un enfant fait (surtout) plus qu‚Äôun parent (plus de param√®tres, de retours, d‚Äôexceptions lev√©es‚Ä¶).
- Les mises √† jour de code seront plus faciles √† organiser (chaque changement du parent induit des changements vers les enfants = s√©curit√©).
- On gagne niveau lisibilit√© et qualit√©, le code est beaucoup plus simple √† lire et √† (r√©-)utiliser.

# I : Interface Segregation Principle (ISP)

Voici ce que dit le principe de s√©gr√©gation de l‚Äôinterface.

    Aucun client ne devrait √™tre forc√© d'impl√©menter des m√©thodes / fonctions qu'il n'utilise pas.

En r√©sum√©‚Ä¶

Il vaut mieux faire plusieurs petites interfaces qu‚Äôune seule grande.

## ‚ùå Code qui ne respecte pas le principe de s√©gr√©gation des interfaces (ISP)

Imaginons que nous ayons besoin d‚Äôafficher des informations dans l‚Äôadministration, comme des utilisateurs et des commandes.

Les utilisateurs peuvent √™tre mis √† jour (le nom, le pr√©nom‚Ä¶), mais pas les commandes !

Une fois que la commande est pass√©e, on ne peut plus la modifier (normal).

Nous avons donc 2 besoins.

- Afficher les informations de l‚Äôobjet requ√™t√© en front.
- Envoyer la mise √† jour vers le back d‚Äôun de nos deux objets.

```php
/**
 * Interface Segregation Principle (ISP) in PHP (not working)
 */

// ‚ùå We have only 1 interface for 2 different needs.
interface EntityInterface
{
    public function getId(): int;
    public function getName(): string;
    public function serializeToApi(): string;
}

/**
 * Class User
 *
 * The class should be displayed in front-end, so getId() and getName() are mandatory.
 * The class should be sent to a web service, the function serializeToApi() is mandatory.
 */
class User implements EntityInterface
{
    private int $id;
    private int $name;

    public function serializeToApi(): string
    {
        return json_encode($this);
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getName(): int
    {
        return $this->name;
    }

    public function setName(int $name): void
    {
        $this->name = $name;
    }
}

/**
 * Class Order
 *
 * The class order is only used to display orders from the user, no modification allowed.
 * The class DOES NOT need serializeToApi().
 */
class Order implements EntityInterface
{
    private int $id;
    private int $name;

    // ‚ùå The function is not needed, but since it is in our interface, we have to implement it.
    public function serializeToApi(): string
    {
        return "";
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function getName(): int
    {
        return $this->name;
    }
}
```

Nous avons 2 besoins distincts, mais la m√™me interface est utilis√©e.

serializeToApi() est incluse dans la classe Order m√™me si celle-ci n‚Äôen a pas besoin.

Du coup, chaque entit√© du projet qui impl√©mente EntityInterface devra impl√©menter la m√©thode pour √™tre post√©e via une API‚Ä¶

M√™me si ce n‚Äôest pas le cas.

## ‚úÖ Code qui respecte le principe de s√©gr√©gation des interfaces (ISP)

Nous avons s√©par√© nos 2 besoins en 2 interfaces s√©par√©es.

```php
/**
 * Interface Segregation Principle (ISP) in PHP
 * 
 * We have 2 dedicated Interfaces for 2 different needs.
 */

interface EntityInterface
{
    public function getId(): int;
    public function getName(): string;
}

interface SerializableInterface
{
    public function serializeToApi(): string;
}

/**
 * Class User
 * 
 * The class should be displayed in front-end, so getId() and getName() are mandatory.
 * The class should be sent to a web service, the function serializeToApi() is mandatory.
 */
class User implements EntityInterface, SerializableInterface
{
    private int $id;
    private int $name;

    public function serializeToApi(): string
    {
        return json_encode($this);
    }

    public function getId(): int
    {
        return $this->id;
    }

    public function setId(int $id): void
    {
        $this->id = $id;
    }

    public function getName(): int
    {
        return $this->name;
    }

    public function setName(int $name): void
    {
        $this->name = $name;
    }
}

/**
 * Class Order
 * 
 * The class order is only used to display passed orders from the user, no modification allowed.
 * The class DOES NOT need serializeToApi().
 */
class Order implements EntityInterface
{
    private int $id;
    private int $name;

    public function getId(): int
    {
        return $this->id;
    }

    public function getName(): int
    {
        return $this->name;
    }
}
```

Le principe ¬´ Interface Segregation Principle ¬ª de SOLID est respect√©, on ne passe de contrat qu‚Äôavec l‚Äôentit√© qui en a besoin.

La classe n‚Äôa pas besoin d‚Äô√™tre post√©e via une API ?

Pas de probl√®me, je n‚Äôimpl√©menterai pas l‚Äôinterface SerializableInterface.

Aussi simple que cela !

## ‚ùå Code qui ne respecte pas le principe de s√©gr√©gation des interfaces (ISP)

Toujours en se basant sur l‚Äôexemple pr√©c√©dent de ShapeInterface, vous devrez prendre en charge les nouvelles formes tri-dimensionnelles de Cuboid et Spheroid. Ces formes devront √©galement calculer volume.

Imaginons ce qui se passerait si vous deviez modifier la ShapeInterface pour ajouter un autre contrat :

```php
interface ShapeInterface
{
    public function area();

    public function volume();
}
```

Maintenant, toute forme que vous cr√©ez doit impl√©menter la m√©thode volume. Cependant, vous savez que les carr√©s sont des formes plates et qu‚Äôils n‚Äôont pas de volume. Ainsi, cette interface forcera la classe Square √† impl√©menter une m√©thode dont elle n‚Äôa pas besoin.

Cela viendrait enfreindre le principe de s√©gr√©gation des interfaces. Au lieu de cela, vous pouvez cr√©er une autre interface appel√©e ThreeDimensionalShapeInterface qui a le contrat volume et les formes tri-dimensionnelles peuvent impl√©menter cette interface :

## ‚úÖ Code qui respecte le principe de s√©gr√©gation des interfaces (ISP)

Cela viendrait enfreindre le principe de s√©gr√©gation des interfaces. Au lieu de cela, vous pouvez cr√©er une autre interface appel√©e ThreeDimensionalShapeInterface qui a le contrat volume et les formes tri-dimensionnelles peuvent impl√©menter cette interface :

```php
interface ShapeInterface
{
    public function area();
}

interface ThreeDimensionalShapeInterface
{
    public function volume();
}

class Cuboid implements ShapeInterface, ThreeDimensionalShapeInterface
{
    public function area()
    {
        // calculate the surface area of the cuboid
    }

    public function volume()
    {
        // calculate the volume of the cuboid
    }
}
```

Il s‚Äôagit d‚Äôune bien meilleure approche. Mais faites attention √† ne pas tomber dans le pi√®ge lors de la saisie de ces interfaces. Au lieu d‚Äôutiliser une ShapeInterface ou une ThreeDimensionalShapeInterface, vous pouvez cr√©er une autre interface, peut-√™tre ManageShapeInterface. Vous pourrez ensuite l‚Äôimpl√©menter sur les formes √† la fois plates et tri-dimensionnelles.

Ainsi, vous pourrez g√©rer les formes avec une application unique :

```php
nterface ManageShapeInterface
{
    public function calculate();
}

class Square implements ShapeInterface, ManageShapeInterface
{
    public function area()
    {
        // calculate the area of the square
    }

    public function calculate()
    {
        return $this->area();
    }
}

class Cuboid implements ShapeInterface, ThreeDimensionalShapeInterface, ManageShapeInterface
{
    public function area()
    {
        // calculate the surface area of the cuboid
    }

    public function volume()
    {
        // calculate the volume of the cuboid
    }

    public function calculate()
    {
        return $this->area();
    }
}
```

Maintenant dans la classe AreaCalculator, vous pouvez remplacer l‚Äôappel √† la m√©thode area avec calculate, et √©galement v√©rifier si l‚Äôobjet est une instance de ManageShapeInterface et non de la ShapeInterface.

## ‚≠êÔ∏è Pourquoi utiliser le principe de s√©gr√©gation des interfaces (ISP) ?

- Am√©liorer la qualit√© du code.
- Le code est plus modulable, plus r√©-utilisable.
- √âviter les grosses interfaces rendra le code plus facile √† lire et √† comprendre.
- On respecte aussi le principe de responsabilit√© unique.

# D : Dependency Inversion Principle (DIP)

Le dernier des principes SOLID stipule :

    Une classe doit d√©pendre de son abstraction, pas de son impl√©mentation.

Autrement dit, on √©vite de passer des objets en param√®tre lorsqu‚Äôune interface est disponible.

Passer en param√®tre une interface permet d‚Äô√™tre certain que l‚Äôobjet que tu manipules, peu importe son type, aura les bonnes m√©thodes associ√©es.

Comme tu te poses la question je te r√©ponds :

Non il n‚Äôy a aucun mal √† passer des objets en param√®tres de tes fonctions.

Ce principe s‚Äôapplique surtout quand tu as une action commune √† exercer pour plusieurs objets diff√©rents !

## ‚ùå Code qui ne respecte pas le principe d‚Äôinversion de d√©pendance (DIP)

Nous avons plusieurs moyens de paiement dans notre projet.

Ils ont une fonction commune qui est le paiement (la m√©thode pay()).

Pour pouvoir √™tre correctement utilis√©s, ils doivent avoir cette m√©thode.

```php
/**
 * Dependency Inversion Principle (DIP) in PHP (not working)
 */

class PayPal
{
	public function pay(int $amount): void
	{
		echo "Discussing with PayPal...\n";
	}
}

class Stripe
{
	public function pay(int $amount): void
	{
		echo "Discussing with Stripe...\n";
	}
}

class AliPay
{
	public function pay(int $amount): void
	{
		echo "Discussing with AliPay...\n";
	}
}

// So many providers exist...

class PaymentProvider
{
	public function goToPaymentPage( PayPal | AliPay | Stripe $paymentChoosen, int $amount ): void
	{
		// ‚ùå This fails here, how can you be sure that $paymentChoosen has a pay() method?
		$paymentChoosen->pay($amount);
	}
}

// Luckily, we had implemented the same method named pay() on all classes, but it was luck, nothing forces us to do so.
$paymentProvider = new PaymentProvider();
$paymentProvider->goToPaymentPage(new PayPal(), 100);
$paymentProvider->goToPaymentPage(new Stripe(), 100);
$paymentProvider->goToPaymentPage(new AliPay(), 100);
```

Ici, le probl√®me est qu‚Äôaucune des classes n‚Äôa de contrat pour s‚Äôassurer que la m√©thode pay() existe bien dans chaque classe.

Dans la m√©thode goToPaymentPage(), on ne pourra jamais √™tre certain que le param√®tre $paymentChoosen a bien une m√©thode pay().

Si le prochain d√©veloppeur qui rajoute un moyen de paiement ne nomme pas ses m√©thodes comme il faut, tout le code plante.

## ‚úÖ Code qui respecte le principe d‚Äôinversion de d√©pendance (DIP)

Une interface pour rappel, c‚Äôest un contrat avec la classe qui l‚Äôimpl√©mente.

Ici on certifie au programme qu‚Äôil trouvera bien la m√©thode pay() dans chacune des classes.

```php
/**
 * Dependency Inversion Principle (DIP) in PHP
 */

interface PaymentInterface
{
    public function pay(int $amount): void;
}

class PayPal implements PaymentInterface
{
	public function pay(int $amount): void
	{
		echo "Discussing with PayPal...\n";
	}
}

class Stripe implements PaymentInterface
{
	public function pay(int $amount): void
	{
		echo "Discussing with Stripe...\n";
	}
}

class AliPay implements PaymentInterface
{
	public function pay(int $amount): void
	{
		echo "Discussing with AliPay...\n";
	}
}

// So many providers exist...

class PaymentProvider
{
	public function goToPaymentPage( PaymentInterface $paymentChoosen, int $amount ): void
	{
		$paymentChoosen->pay($amount);
	}
}

$paymentProvider = new PaymentProvider();
$paymentProvider->goToPaymentPage(new PayPal(), 100);
$paymentProvider->goToPaymentPage(new Stripe(), 100);
$paymentProvider->goToPaymentPage(new AliPay(), 100);
```

On passe d√©sormais en param√®tre l‚Äôinterface PaymentInterface.

Chaque objet (PayPal, Stripe‚Ä¶) peut √™tre utilis√© en param√®tre donc, √©tant donn√© qu‚Äôil impl√©mente cette interface.

Nous sommes d√©sormais certains que chaque objet pass√© aura bien une m√©thode pay() !

En plus de √ßa, le code est bien plus √©l√©gant √† lire dans la m√©thode goToPaymentPage().

De plus, avec 20 moyens de paiement, la lisibilit√© des param√®tres aurait √©t√© ing√©rable.

## ‚ùå Code qui ne respecte pas le principe d‚Äôinversion de d√©pendance (DIP)

Voici l‚Äôexemple d‚Äôun PasswordReminder qui se connecte √† une base de donn√©es MySQL :

```php
class MySQLConnection
{
    public function connect()
    {
        // handle the database connection
        return 'Database connection';
    }
}

class PasswordReminder
{
    private $dbConnection;

    public function __construct(MySQLConnection $dbConnection)
    {
        $this->dbConnection = $dbConnection;
    }
}
```

Tout d‚Äôabord, le MySQLConnection est le module de bas niveau tandis que le PasswordReminder est celui de haut niveau, mais selon la d√©finition du D de SOLID, qui indique de Depend on abstraction, not on concretions. Ce fragment de code ci-dessus enfreint ce principe, car la classe PasswordReminder est forc√©e de d√©pendre de la classe MySQLConnection.

Plus tard, si vous venez √† devoir modifier le moteur de la base de donn√©es, vous aurez √©galement √† modifier la classe PasswordReminder, ce qui enfreindrait l‚Äôopen-close principle.

## ‚úÖ Code qui respecte le principe d‚Äôinversion de d√©pendance (DIP)

La classe PasswordReminder ne doit pas se pr√©occuper de la base de donn√©es utilis√©e par votre application. Pour r√©soudre ces probl√®mes, vous pouvez coder sur une interface √©tant donn√© que les modules de haut et de bas niveau doivent d√©pendre de l‚Äôabstraction :

```php
interface DBConnectionInterface
{
    public function connect();
}
```

L‚Äôinterface a une m√©thode de connexion et la classe MySQLConnection impl√©mente cette interface. De plus, au lieu de directement indiquer la classe MySQLConnection dans le constructeur du PasswordReminder, vous devriez plut√¥t indiquer le type de la DBConnectionInterface. Et, quel que soit le type de base de donn√©es utilis√©e par votre application, la classe PasswordReminder pourra se connecter √† la base de donn√©es sans aucun probl√®me tout en respectant le principe ouvert-ferm√©.

```php
class MySQLConnection implements DBConnectionInterface
{
    public function connect()
    {
        // handle the database connection
        return 'Database connection';
    }
}

class PasswordReminder
{
    private $dbConnection;

    public function __construct(DBConnectionInterface $dbConnection)
    {
        $this->dbConnection = $dbConnection;
    }
}
```

## ‚≠êÔ∏è Pourquoi utiliser le principe d‚Äôinversion de d√©pendance (DIP) ?

- Un code beaucoup plus facile √† modifier, on peut ajouter des fonctionnalit√©s sans crainte de bug.
- Une lisibilit√© et une qualit√© de code accrue.

Voil√†, c‚Äô√©tait le dernier principe de SOLID‚Ä¶ üôÇ

# Conclusion

Pour moi, l‚Äôutilisation de SOLID dans ton quotidien de d√©veloppeur doit √™tre une habitude. Ou du moins quelque chose que tu dois garder en t√™te. Savoir que √ßa existe et comprendre comment cela fonctionne est d√©j√† un grand pas. Si jamais c‚Äôest toujours un peu flou de ton c√¥t√©, n‚Äôh√©site pas √† laisser un commentaire que je vois comment je peux t‚Äôaider.

# R√©capitulatif des 5 principes SOLID

En quelques mots pour r√©sumer et finir cet article.

- (S) Le principe de responsabilit√© unique te permet de t‚Äôassurer qu‚Äôune fonction ne fait qu‚Äôune seule et unique chose, mais qu‚Äôelle le fait bien.
- (O) Le principe Ouvert/Ferm√© te demande de ne pas modifier le comportement d‚Äôune action en fonction d‚Äôun param√®tre, mais plut√¥t d‚Äô√©tendre les capacit√©s dudit param√®tre gr√¢ce √† une fonction d√©finie en amont.
- (L) Le principe de substitution de Liskov te permet d‚Äôinterchanger les enfants d‚Äôune classe sans que cela ait d‚Äôincidence sur l‚Äôex√©cution du code.
- (I) Le principe de s√©gr√©gation des interfaces te demande de s√©parer les actions le plus possible.
- (D) Le principe d‚Äôinversion de d√©pendance pr√©conise de passer des abstractions en param√®tre (des contrats gr√¢ce aux interfaces) plut√¥t que les objets eux-m√™mes.

